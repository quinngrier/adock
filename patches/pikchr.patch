diff -N -r -u a/doc/grammar.md b/doc/grammar.md
--- a/doc/grammar.md	2022-12-07 03:14:59.000000000 -0800
+++ b/doc/grammar.md	2023-01-04 01:33:23.610977094 -0800
@@ -44,8 +44,9 @@
   *  STRING  &rarr;  A string literal that begins and ends with
      double-quotes (U+0022).  Within the string literal, a double-quote
      character can be escaped using backslash (U+005c).  A backslash
-     can also be used to escape a backslash.  No other escape sequences
-     are recognized.
+     can also be used to escape a backslash.  The "<" and ">" characters
+     can also be escaped to emit them literally instead of as "&lt;" and
+     "&gt;".  No other escape sequences are recognized.
 
   *  COLORNAME &rarr;  One of the 140 official HTML color names, in 
      any mixture of upper and lower cases.  The value of a COLORNAME is
diff -N -r -u a/pikchr.c b/pikchr.c
--- a/pikchr.c	2022-12-07 03:14:59.000000000 -0800
+++ b/pikchr.c	2023-01-04 01:33:23.614977168 -0800
@@ -5073,6 +5073,9 @@
       if( j<nz && (j+1==nz || z[j+1]=='\\') ){
         pik_append(p, "&#92;", -1);
         j++;
+      }else if( j<nz && (z[j+1]=='<' || z[j+1]=='>') ){
+        pik_append(p, &z[j+1], 1);
+        j++;
       }
       nz -= j+1;
       z += j+1;
@@ -6182,6 +6185,10 @@
 ** "&lt;" as a single character.  Multi-byte UTF8 characters count
 ** as a single character.
 **
+** Omit "\<" and "\>" escapes entirely, along with anything that lies
+** between matching pairs of these escapes. These escapes are used to
+** output SVG tags, which are of course not displayed.
+**
 ** Attempt to scale the answer by the actual characters seen.  Wide
 ** characters count more than narrow characters.  But the widths are
 ** only guesses.
@@ -6190,26 +6197,31 @@
   int n = pToken->n;
   const char *z = pToken->z;
   int cnt, j;
+  int visible = 1;
   for(j=1, cnt=0; j<n-1; j++){
     char c = z[j];
     if( c=='\\' && z[j+1]!='&' ){
       c = z[++j];
+      if( c=='<' || c=='>' ){
+        visible = c=='>';
+        continue;
+      }
     }else if( c=='&' ){
       int k;
       for(k=j+1; k<j+7 && z[k]!=0 && z[k]!=';'; k++){}
       if( z[k]==';' ) j = k;
-      cnt += 150;
+      if (visible) cnt += 150;
       continue;
     }
     if( (c & 0xc0)==0xc0 ){
       while( j+1<n-1 && (z[j+1]&0xc0)==0x80 ){ j++; }
-      cnt += 100;
+      if (visible) cnt += 100;
       continue;
     }
     if( c>=0x20 && c<=0x7e ){
-      cnt += awChar[c-0x20];
+      if (visible) cnt += awChar[c-0x20];
     }else{
-      cnt += 100;
+      if (visible) cnt += 100;
     }
   }
   return cnt;
diff -N -r -u a/pikchr.y b/pikchr.y
--- a/pikchr.y	2022-12-07 03:14:59.000000000 -0800
+++ b/pikchr.y	2023-01-04 01:37:50.559895041 -0800
@@ -2304,6 +2304,7 @@
   const char *z;
   PToken *aTxt;
   unsigned allMask = 0;
+  int visible = 1;
 
   if( p->nErr ) return;
   if( pObj->nTxt==0 ) return;
@@ -2467,10 +2468,14 @@
     while( nz>0 ){
       int j;
       for(j=0; j<nz && z[j]!='\\'; j++){}
-      if( j ) pik_append_text(p, z, j, 0x3);
+      if( j ) pik_append_text(p, z, j, 0x2 | visible);
       if( j<nz && (j+1==nz || z[j+1]=='\\') ){
         pik_append(p, "&#92;", -1);
         j++;
+      }else if( j<nz && (z[j+1]=='<' || z[j+1]=='>') ){
+        visible = z[j+1]=='>';
+        pik_append(p, &z[j+1], 1);
+        j++;
       }
       nz -= j+1;
       z += j+1;
@@ -3580,6 +3585,10 @@
 ** "&lt;" as a single character.  Multi-byte UTF8 characters count
 ** as a single character.
 **
+** Omit "\<" and "\>" escapes entirely, along with anything that lies
+** between matching pairs of these escapes. These escapes are used to
+** output custom SVG tags, which are of course not displayed.
+**
 ** Attempt to scale the answer by the actual characters seen.  Wide
 ** characters count more than narrow characters.  But the widths are
 ** only guesses.
@@ -3588,26 +3597,31 @@
   int n = pToken->n;
   const char *z = pToken->z;
   int cnt, j;
+  int visible = 1;
   for(j=1, cnt=0; j<n-1; j++){
     char c = z[j];
     if( c=='\\' && z[j+1]!='&' ){
       c = z[++j];
+      if( c=='<' || c=='>' ){
+        visible = c=='>';
+        continue;
+      }
     }else if( c=='&' ){
       int k;
       for(k=j+1; k<j+7 && z[k]!=0 && z[k]!=';'; k++){}
       if( z[k]==';' ) j = k;
-      cnt += 150;
+      if (visible) cnt += 150;
       continue;
     }
     if( (c & 0xc0)==0xc0 ){
       while( j+1<n-1 && (z[j+1]&0xc0)==0x80 ){ j++; }
-      cnt += 100;
+      if (visible) cnt += 100;
       continue;
     }
     if( c>=0x20 && c<=0x7e ){
-      cnt += awChar[c-0x20];
+      if (visible) cnt += awChar[c-0x20];
     }else{
-      cnt += 100;
+      if (visible) cnt += 100;
     }
   }
   return cnt;
